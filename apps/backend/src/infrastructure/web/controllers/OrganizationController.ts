// apps/backend/src/infrastructure/web/controllers/OrganizationController.ts

import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { Organization, OrganizationStatus } from '../../../core/domain/organization';
import { OrganizationService } from '../../../core/application/services/OrganizationService';
import { getActorUserId, getTenantId } from '../middlewares/context';

export class OrganizationController {
  private readonly createOrganizationBodySchema = z.object({
    code: z.string().trim().min(1).max(100).optional(),
    name: z.string().trim().min(1).max(200),
    status: z.nativeEnum(OrganizationStatus).optional(),
  });

  private readonly updateOrganizationBodySchema = z.object({
    code: z.string().trim().min(1).max(100).nullable().optional(),
    name: z.string().trim().min(1).max(200).optional(),
    status: z.nativeEnum(OrganizationStatus).optional(),
  });

  constructor(private readonly organizationService: OrganizationService) {}

  async getOrganizations(req: Request, res: Response, next: NextFunction) {
    try {
      const tenantId = getTenantId(req);
      const organizations = await this.organizationService.getAllOrganizations(tenantId);
      res.json(organizations);
    } catch (err) {
      next(err);
    }
  }

  async createOrganization(req: Request, res: Response, next: NextFunction) {
    try {
      const tenantId = getTenantId(req);
      const actorUserId = getActorUserId(req);
      const body = this.createOrganizationBodySchema.parse(req.body);

      const organization = await this.organizationService.createOrganization({
        id: '', // Will be generated by the service/repository
        tenantId,
        name: body.name,
        code: body.code,
        status: body.status || OrganizationStatus.ACTIVE,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdByUserId: actorUserId,
        updatedByUserId: actorUserId,
      });
      res.status(201).json(organization);
    } catch (err) {
      next(err);
    }
  }

  async updateOrganization(req: Request, res: Response, next: NextFunction) {
    try {
      const tenantId = getTenantId(req);
      const actorUserId = getActorUserId(req); // actorUserId will be used if we implement `updatedByUserId` in service
      const id = z.string().uuid().parse(req.params.id);
      const body = this.updateOrganizationBodySchema.parse(req.body);

      const updateData: Partial<Organization> = { updatedByUserId: actorUserId };
      if (body.code !== undefined) {
        updateData.code = body.code === null ? undefined : body.code; // Convert null to undefined for Partial<Organization>
      }
      if (body.name !== undefined) updateData.name = body.name;
      if (body.status !== undefined) updateData.status = body.status;

      const organization = await this.organizationService.updateOrganization(id, updateData);
      if (!organization) {
        res.status(404).json({ error: 'Not Found' });
        return;
      }

      res.json(organization);
    } catch (err) {
      next(err);
    }
  }

  async deleteOrganization(req: Request, res: Response, next: NextFunction) {
    try {
      const tenantId = getTenantId(req); // tenantId will be used for authorization in service
      const actorUserId = getActorUserId(req); // actorUserId will be used for authorization in service
      const id = z.string().uuid().parse(req.params.id);

      // Assuming soft delete is handled by the service now.
      // The service might return a boolean indicating success or throw an error.
      await this.organizationService.deleteOrganization(id); // service should handle not found
      res.status(204).send();
    } catch (err) {
      next(err);
    }
  }
}
